---
sidebar_position: 5
---

# 角色

角色是 Arrow 的主要资源类型之一，
封装了*名称*、*颜色*标签以及任意数量的动态键值*[标签](#标签)*。

角色可以被节点引用，并且被一些内置节点引用。
这意味着我们可以跟踪与角色相关的每个资源，
例如 [Dialog](../nodes/dialog) 和 [Monolog](../nodes/monolog) 节点。

更令人兴奋的是，角色可以封装任意属性作为其[标签](#标签)。
这些是可以从*检查器*面板初始管理
和/或在运行时动态管理的 `key:value` 键值对集合。

标签也可以在不同节点中暴露，如 [Content](../nodes/content)、[Interaction](../nodes/interaction) 等，
使用 `{character_name.tag_key}` 占位符。

> 要创建或编辑 `角色`，请转到 `检查器` 面板的相应选项卡。
> 在那里你也可以设置初始标签值。

## 标签 {#标签}

标签被设计为实现简单但高度灵活和动态。
它们是由角色资源封装的 `key: value`（全部为字符串）数据对。

> 标签不是独立资源。它们没有 UID，只作为
> 角色 `tag` 集合/字典下的 `key:value` 实体存在。

与[变量](./variables-logic)不同，角色标签只支持字符串数据，但更重要的是，
它们在运行时动态管理。换句话说，
**标签可以按需创建或被删除/取消定义**。
这意味着在删除标签时应该格外小心，
特别是如果它们应该在某个带有文本内容的节点中被暴露。

### 常见用途和潜力

+ 使用 [Tag-Pass](../nodes/tag-pass) 和 [Tag-Edit](../nodes/tag-edit) 节点进行动态事件管理

    游戏叙事设计中一个非常常见的场景是将事件限制在某些条件下。
    对于这种情况，你总是可以使用变量；但当条件数量相当大时，
    定义和管理许多变量可能会很麻烦。
    使用角色标签更容易定义和管理此类事件；
    使用 [Tag-Edit](../nodes/tag-edit) 添加、删除或操作，并使用 [Tag-Pass](../nodes/tag-pass) 节点检查。
    
    > 有关更多信息和示例，请查看上述节点的文档。

+ 数据封装和解析

    在早期 Arrow 版本中，我们只有[变量](./variables-logic)来保存游戏数据并将它们作为文本片段暴露。
    这意味着要管理许多相关数据，你必须创建许多变量。
    这个过程和结果不一定整洁干净。
    
    我们现在可以创建角色资源来包装和管理数据集合作为 `key: value` 标签，
    即使该资源不代表传统定义中的故事角色。
    例如，游戏的库存可以定义为一个角色。
    
    角色标签可以在主要的内置文本节点中暴露，
    使用类似 `{character_name.tag_key}` 的 mustache 占位符。

    此功能的常见用途是为角色分配数据，
    如 `name`、`alias`、`age`、`superpower`、`vehicle` 等，
    并在需要这些值的任何地方使用它们。
    然后我们只需要更新一个标签的值，就可以让它们全部更新，甚至在运行时。
    
    我们可以使用 [Tag-Edit](../nodes/tag-edit) 节点操作标签。
    
    > 标签只支持字符串（文本）键和值，
    > 对于其他数据类型，[变量](./variables-logic)提供更多优势。
 
    > 不支持或建议在标签值内解析 `{variable}`，
    > 但可能作为某些内置节点内部机制的副作用而工作。

+ 跟踪、引用和引用

    检查器面板的角色选项卡提供跟踪功能，
    可以列出引用特定角色的所有节点，
    或在其内容中引用属于该角色的标签（mustache 占位符）的节点。
    
    > 这些按引用时间排序。
    
    你可以利用此功能实现不同目的，包括以下示例：

    + 定位存在
        
        假设你想定位关于名为 `Hero` 的角色的节点，
        但你不想在其中准确暴露任何特殊标签（甚至 `{Hero.name}`）。
        你可以为 Hero 创建一个带有任意键（例如 `_` 或任何你喜欢的约定）的标签，
        以及无文本（即零长度空白）值，然后在那些节点支持暴露的文本字段中使用它。
        暴露的空白值不会改变玩家体验，但你始终可以找到那些节点，
        因为检查器像跟踪任何其他暴露的标签一样跟踪它们。
        
        > 该标签也可以使用全局文本搜索查询 `Hero._`（从状态栏）。
    
    + 分类

        或者，你可以使用无值（空白）标签和任意键
        来分类节点。例如，你可以创建空白标签，如
        `{Hero._love_affair}`、`{Hero._nightmares}`、`{Hero._battles}`
        来分类不同的 [Content](../nodes/content)、[Dialog](../nodes/dialog)、[Interaction](../nodes/interaction) 等。
        这些标签不会向玩家打印任何文本，但可以被定位，
        甚至更好的是可以使用全局文本搜索查询。

        > 另一种分类和定位节点的通用方法是在*节点注释*中放置分类徽章
        >（使用任何你喜欢的格式，如 `[battle-scene, love-affair, duel]`）
        > 并使用全局文本搜索查询它们。

        > 另请参阅[项目组织](./project-organization)

### 注意事项！

**能力越大\[动态\]，责任越大**

未定义的标签（包括没有或无效键的标签，例如 `{Hero.}`）
可以在许多节点中暴露，因此可以被检查器引用和定位。
但除非在运行时或稍后在检查器中创建/定义，
否则它们*将被打印为它们所是的占位符文本*，
而不是值（因为没有真正的值）。

这是艺术家/开发者的责任，确保
暴露的标签在需要时确实存在于内存中。

一个通常的好做法是，只对预设标签使用占位符
（在编辑器中初始化），并且永远不要在运行时取消设置或删除它们。

另一方面，动态创建（和删除）的标签可用于
如上所述的事件管理。
