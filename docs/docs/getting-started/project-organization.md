---
sidebar_position: 6
---

# 项目组织

项目组织的重要性随着项目规模的增加而增加。
Arrow 带有必要的功能，让用户能够控制不断增长的项目。
很多功能，如*连续性安全*和*资源跟踪*，
在后台默默工作，让你可以专注于创意方面。
但还有其他事项需要考虑以保持管理有序。
将项目划分为多个章节（文件/文档）或场景，
为复杂和可重复的逻辑创建宏，你可能遵循的命名约定，
同时在单个项目文档上工作的作者数量，
共享资源的范围，以及许多其他你应该了解的主题，
以免你的项目变得庞大且失控！

本文档介绍帮助你掌控工作流程的功能和底层功能，
随着工作空间的增长。
它包含有用的技术细节
以及一些最佳实践。

## 连续性安全

想象一个非常常见的场景，你有一个焦点节点，
被来自不同场景的几个 [Jump](../nodes/jump) 节点用作目标节点。
由于项目太大，可能无法跟踪所有引用，
并删除或替换该焦点节点，因此使所有引用的跳转无效，
破坏事件序列并损害叙事的连续性。
这种情况可能只会在测试或甚至生产中显现为头痛。

Arrow 的连续性安全来拯救！

连续性安全是 Arrow 编辑器的核心概念。
当编辑器不允许你删除某些节点、宏、变量或角色时，你可能会体验到它。
你不需要主动关心它，因为它几乎都是自动的，
除非你使用相对不安全的操作，例如跳转到另一个跳转。

在底层，Arrow 跟踪资源之间的大多数可见和不可见关系。
Arrow 知道你有这样的跳转，所以它会阻止你删除那个被使用或引用的目标节点，
直到你也删除或更改所有其他用户或依赖节点。

它适用于所有主要数据类型和内置节点，包括[变量](./variables-logic)和[角色](./characters)，
无论使用是直接的，如在 [Dialog](../nodes/dialog) 和 [User-Input](../nodes/user-input) 中，还是间接的，
通过在文本节点如 [Monolog](../nodes/monolog) 或 [Content](../nodes/content) 中暴露 mustache 占位符。

你可以通过在*检查器*面板的相应选项卡中
查找引用定位器（选项按钮和箭头）来检查哪些节点依赖于任何资源。
> 如果没有依赖节点，这些按钮可能不会显示。

## 可移植性

从一开始，Arrow 就被开发为尽可能可移植。
它不依赖于设备上安装的任何其他工具。
它可以在你的项目文件所在的 U 盘上运行，
或者位于主设备上并按需在不同工作目录之间切换。
它甚至可以作为 [Web 应用][web-app]使用，可以在浏览器中存储数据。

### 配置

包括工作目录、主题、历史大小等在内的主要配置
从*偏好设置*面板管理。

> 要访问*偏好设置*面板，请按编辑器左上角的 `Arrow` 菜单按钮并选择 `Preferences`。

默认情况下，Arrow 将其配置保存在尽可能靠近其可执行文件的位置。
如果它自己的驻留目录可访问，将创建一个 `.arrow.config` 文件；
否则，本地应用目录（取决于用户和操作系统）是下一个尝试的位置。

你也可以使用以下 [CLI](../technical/cli-arguments) 参数来定义自定义路径到目录，
Arrow 每次运行时都会在那里保存其配置文件：

```shell
$ Arrow --config-dir '/home/USER/.config/'
```

> 如果你不想创建任何配置文件，请改用 `--sandbox` 参数。

### 工作目录和切换

Arrow 对其工作目录的优先级则相反，即 `.arrow.project` 文件所在的位置。
Arrow 编辑器查找文件的位置由你的配置定义（见上文）。
默认值是本地应用目录；但你可以从偏好设置菜单更改它。

你也可以使用以下 [CLI](../technical/cli-arguments) 参数覆盖它：

```shell
$ Arrow --work-dir '/home/USER/my_other_adventure/'
```

> Arrow 将每个工作目录视为独立的工作空间。
> 我们可以为每个将被划分为多个文档的大型项目创建一个目录。
> 要在不同工作目录之间切换，
> 只需从偏好设置面板更改相应的配置。
> Arrow 会自动加载现有的 `.arrow.project` 或初始化一个新的。
> 你也可以设置 Arrow 在每个项目自己的目录中创建 `.arrow.config` 文件
> 并在运行时在它们之间切换，特别是如果你想同时打开多个 Arrow 编辑器实例。

## 分布式唯一资源标识符

跟踪资源（包括场景、宏、变量、角色和节点）是一个棘手的过程。
当你重命名一个已经在数百个文本密集型节点中用 mustache 占位符暴露的变量时，
Arrow 应该能够并确实承担更新所有这些占位符的责任。
每当你在项目中编辑某些内容时，都会采取类似的底层操作。

Arrow 需要始终知道每个资源的*身份*，
无论我们手动分配给它们的名称或我们放置它们的位置。
因此，每个资源在创建时都会被赋予一个不可变的唯一标识符（UID）。
Arrow 保持这些 UID 不变，永不回收它们，也永不将它们重新用于其他资源。
当你编辑资源（例如更新场景或节点名称）时，
Arrow 使用资源的唯一标识符在项目文档中查找正确的资源。

> 另请参阅：[项目数据结构](../technical/project-data-structure)

历史上，这些 UID 是通过递增保存在每个文档中的整数种子生成的（即 `next_resource_seed` 属性）。
这种方法适用于只有一个作者在单个项目文件上工作的相对较小的项目。
但当我们尝试将项目划分为多个文件，或多个作者尝试合并他们的工作时，事情变得复杂。

在旧的已弃用方法中，当团队中的第一个作者创建资源时，他或她的项目种子会更新；
而其他作者的副本在文档合并之前不会得到更改。
如果其他作者同时尝试编辑他们的文件，而没有第一作者的更改，
由于使用旧种子，他们会得到与第一作者相同的 UID，
用于他们完全不同的资源，即使他们在完全不同的场景上工作。

另一个可能的头痛是将项目划分为多个文件。
这些文件中的 UID 也会从 `0` 开始向上。
这意味着你不能简单地混合多个文档来修改或运行，
或在它们之间导航而无需额外的簿记工作。

为了解决这些问题，我们的 UID 生成算法应该以某种方式知道谁在任何时候编辑文档，
以及正在编辑的文档是否是集合的一部分，并可能在运行时与其他文档混合。
换句话说，Arrow 编辑器应该确保其生成的 UID 在多文档项目的范围内永不冲突。

我们也不想使用中央权威来生成 UID。

幸运的是，这不是一个令人惊讶的新问题。
许多 UID 生成算法被设计为在多个同时生产者之间*分布* UID 生成的权利。

Arrow（*v2* 及更高版本）中最根本的变化之一，几乎影响了所有其他内容，
是向新的*分布式 UID*生成算法的迁移。

实现了两种方法，让 Arrow 用户选择更适合其工作流程的方式：

1. Snow（通常不推荐）：

    此方法几乎与著名的 [Snowflake] 算法相同；但使用特定于项目的纪元。
    要激活此方法，你应该通过手动编辑文档，将每个项目文件的 `epoch` 属性
    设置为某个共享的 Unix 时间（毫秒）。
    生产者或作者可以从编辑器切换（如下文进一步解释）。

    > **注意！**
    > 除非你需要知道每个资源创建的确切时间，
    > 否则此方法相对于推荐的默认*原生*方法（下文）没有特别优势。

2. Native（默认）：

    默认和推荐的方法是 Arrow 自己的*原生*分布式 UID 生成算法。
    
    > 此算法的所有参数可以从编辑器的*作者*面板更改。
    > 从检查器的项目选项卡点击*作者*按钮访问面板。
    
    从*作者*面板，你可以定义多个贡献者
    并为每个人分配一个*唯一的作者标识符*（AUID）。
    在后台，将为每个作者创建和跟踪一个*增量种子*。
    这些值将与*章节 ID*混合，
    对于划分为多个文件的项目，每个文档可以有唯一的章节 ID。
    章节 ID 由你选择并设置为你认为合适的值。
    
    这些参数（章节 ID、作者 ID 及其各自的增量种子）
    被混合以形成每个资源的 53 位 UID。
    换句话说，每次为每个资源创建一个数字，
    方法是将以下位放在一起：
    
    + 10 位章节 ID（0 - 1024）
    +  6 位作者 ID（0 - 64）
    + 37 位用于每个作者每章超过 1370 亿个资源。

    这些 UID 将是分布式的、高性能的、最小的，
    并适合双精度浮点表示，
    允许在具有类型限制的语言中更容易实现 Arrow 运行时环境。

    例如，章节 `0` 中作者 `0` 创建的第 `7` 个资源获得 `7` 作为其 UID，
    同一章节 `0` 中作者 `1` 的第 `7` 个资源获得 `137438953479`，
    另一章节 `1` 中作者 `1` 的第 `7` 个资源获得 `8933531975687`。

    查看二进制（以 2 为基数）系统中的底层位会变得直观，其中只有两个数字 `0` 和 `1` 存在。
    十进制的 `0` 等于二进制的 `0`，`1` 是 `1`；但十进制的 `2` 是二进制的 `10`，
    `3` 是 `11`，`4` 是 `100`，`5` 是 `101`，`6` 是 `110`，`7` 是 `111`。
    
    当我们将上述每个 UID 的数字部分并排放置（即章节-作者-种子）时，我们得到：

    + **`0-0-7`**：二进制 `0000000000-000000-0000000000000000000000000000000000111` = 十进制 `7`
    + **`0-1-7`**：二进制 `0000000000-000001-0000000000000000000000000000000000111` = 十进制 `137438953479`
    + **`1-1-7`**：二进制 `0000000001-000001-0000000000000000000000000000000000111` = 十进制 `8933531975687`

    章节 `5` 中作者 `4` 的第 `3` 个资源呢？
    位部分 **`5-4-3`** 将是二进制 `0000000101-000100-0000000000000000000000000000000000011`
    并给我们 `44530220924931` 十进制 UID。

> 对于正常工作流程，原生算法（默认激活）是一个很好的选择，推荐使用。

你实际上不需要关心这些东西在底层是如何工作的。
你只需要知道何时以及为什么一些大数字会出现在你的项目中，
以及为什么在开始编辑项目之前正确设置作者和章节 ID 值如此重要。

> 请务必阅读下面的[章节和作者](#章节和作者)。

## 管理大型工作空间

### 命名和分类实践

我们在上面讨论了分布式唯一资源标识符（或 UID）。
每个资源的 UID 默认反映在其 `name` 属性中，以 base-36 字符串化。
某些资源可能还会在反射中添加前缀，如 `scene_` 或 `var_`。
这些名称自然是唯一的，因为它们由完全唯一的 UID 生成。

Arrow 编辑器的检查器面板允许用户从各自的选项卡重命名任何或所有资源。
其主要核心负责之后重命名对该资源的所有引用（例如暴露的 `{variable}`）。

重命名与否，Arrow 尝试保持这些名称唯一
（除非你在构建前关闭硬编码设置，不建议这样做）。
这意味着如果你将资源重命名为未来资源的 UID 反射
（将从未使用的种子创建），你可能会得到重复的名称。
Arrow 通过在已被作者使用的新生成名称上添加下划线（`_`）后缀来解决这个问题。

例如，章节 `0` 中作者 `0` 的第 `10` 个资源的 base-36 表示是字母 `a`。
如果你将那里的第 `9` 个资源重命名为 `a`，然后创建一个新资源（即第 `10` 个，所以预期的 `a`），
Arrow 将新资源的名称修正为 `a_`。

Arrow 名称区分大小写。换句话说，资源 `a` 与资源 `A` 不同且独立。
这意味着我们可以在上面的例子中使用 `A` 作为重命名的第 9 个资源，并为第 10 个获得正常的 `a`。

有了这些底层功能的知识，
让我们讨论你可能会发现有用的约定和良好实践：

**只重命名你需要的**

在一个成长的大型项目中，将有几乎无限数量的资源（场景、节点等）。
你是决策者。你决定哪些资源应该重命名为更人性化的标题。
一个好的做法是只重命名真正需要容易快速找到的节点，如焦点节点。
许多在大分支中是小齿轮的节点可以保留它们自己的机器生成的名称。
你始终可以使用替代方法（下面提到）来分类和轻松定位你的无名节点。
另一方面，给每个场景、角色或变量自己有意义的名称会更有意义。

**为意义和范围重命名**

一些资源，包括场景、宏、变量和角色，可以按名称过滤。
有意义地命名这些资源，可选地命名空间或范围化，以及惯用语，
允许你在可能很大的列表中轻松过滤和找到它们。

例如，如果你用 `love-{major-event}-{minor-event}` 命名空间所有爱情场景
（例如 `love-triangle-duel`、`love-triangle-first-encounter`），
不仅你以后可以在许多其他场景中过滤和识别它们，
而且当列表按字母顺序排序时，它们会被列在一起。

你的资源在使用、在网格上查看和暴露时也会看起来更有意义
（例如 `{Hero.alias}` 与 `{char_x1y2.a}`）。

**优先分类**

资源名称可以反映更多关于其类型、目的和类别的信息。
一个节点可以命名为 `love-in-first-sight-01`；但还有许多其他（更漂亮的）方法也可以做到。

节点（开发者）注释非常方便。
你可以在节点注释中放置无限数量的分类徽章或主题标签
（使用任何你喜欢的格式，如 `[battle-scene, love-affair, duel]`）
并使用全局文本搜索（从状态栏）查询它们。

也考虑在适当时使用[角色](./characters)标签来创建关系。

**在工作空间中为资源名称保持一致的大小写约定**

在命名节点时使用特殊大小写，
如 `snake_case`、`Title Case`、`CamelCase`、`kebab-case` 等，
提供许多优势。

事情保持整洁，你可以一眼认出它们，
特别是如果你为不同目的使用不同的大小写
（例如角色使用 `CamelCase`，标签使用 `kebab-case`，变量使用 `snake_case`）。

你几乎永远不会与默认节点名称冲突，
因为我们的 base-36 表示不包括
许多情况下使用的破折号、空格、下划线或大写字符。
例如，名称 `heyday` 是 UID `1053043162` 的表示，
但你永远不会从 Arrow 得到它作为 `Heyday`、`hey-day` 或 `hey_day`。

还要注意，Arrow 不偏好上述任何一种情况。
尽管 Arrow 默认用下划线（`_`）替换某些名称中的受限字符，
以使它们更容易和更安全地暴露，但任何其他允许的字符，包括破折号（`-`），
也会非常安全。这是你的个人、团队或项目约定，需要制定和维护。

### 场景和宏

场景是项目组织的第一线。

Arrow 项目可以有无限数量的场景。
唯一的限制是你设备的物理内存和存储。
当你打开一个项目文件时，Arrow 会将其所有数据加载到设备的内存中。
它可能还会在那里创建几个副本，用于编辑历史、快照等。
但由于现代设备可以处理足够多的场景，
你最有可能只需要关心每个文档中场景的创意方面。

> 要创建新场景和/或打开它们进行编辑，请转到*检查器*面板的场景选项卡。

一个非常好的做法是遵循
小说家和编剧几十年来一直使用的相同约定。
这些作者将他们的戏剧作品组织为多个章节/集
以及每个章节的多个场景。这得到了 Arrow 的支持和推荐。

我们可以将项目（工作目录）划分为多个章节（`.arrow` 文档），
每个章节划分为我们认为合适数量的场景。
主要事件可以发生在章节/文件中，次要事件在场景中，
或者任何其他适合你项目需求的划分。
你甚至可以根据你的创作将项目划分为每个角色、地点等一个章节/文档。

关键是要划分，因为项目的节点数量可以增长得非常快。

> 请务必阅读[章节和作者](#章节和作者)了解更多详情。

使用宏是管理划分的另一种方式。它们是具有变化的场景：双重身份！
本质上，它们与其他场景相同，实际上是相同的资源类型，但有一个可选的 `macro` 属性设置为 `true`；
但它们在编辑器、控制台和运行时都享有特殊待遇。

你可以在 [Macro-Use](../nodes/macro-use) 节点内播放它们，或 [Jump](../nodes/jump) 到它们的一个节点并使它们像普通场景一样播放。
区别在于第一种包含使用（宏独有）中，
观察到 EOL（即行结束）被解释为我们应该继续向前播放父/容器场景，
与正常场景和跳转到的宏相反，EOL 停止分支的执行，很可能是游戏。

宏被设计为
可重复的计算单元、可重用块或函数；
否则它们相对于场景没有实际优势。

一个常见用途是在状态管理中使用相对复杂的逻辑。
例如，你可以创建一个宏来根据其他变量（boss_strength 和 battle_outcome）
用不同的因子更新多个变量（stamina、skill、health），
每次你的英雄与 boss 战斗时。
然后你可以在每个战斗场景/分支中重用这个宏。你避免了复制粘贴，
当你打算更改所有得分事件时，你只需要编辑项目的一个构建块。

> 有关宏如何处理的更多信息，请查看：[Macro-Use](../nodes/macro-use)

### 章节和作者 {#章节和作者}

新项目文档（即 `.arrow` 文件）从模板（空白项目）创建，
包括一个基本场景，其中一个 [Entry](../nodes/entry) 连接到一个最小的 Hello-World [Content](../nodes/content) 节点。

这个未命名的项目有几个非常重要的属性，
你应该首先处理的事情：

+ 此文档的章节 ID，默认设置为 `0`
+ 其活动作者，称为 `匿名贡献者`，默认作者 ID 为 `0`

这些属性影响此文件中创建的所有 UID（包括现有的预设 UID），
从长远来看，影响你的项目被划分为多个文件时的文档间关系。

在开始之前正确设置它们非常重要。

以下是标准或建议的程序，
特别是当你打算将工作划分为多个章节/文件时推荐：

**大型项目文档创建**

尝试使用干净的工作目录，为每个独立的大型项目提供新的 `.arrow.project`。

每次创建新文档时，请遵循以下步骤：

+ 首先保存它
+ 打开*作者*面板（从*检查器*面板的项目选项卡）
+ 设置唯一的 `章节` ID **并按更新**
    > 值和顺序是可选的，但最好避免重复使用它们，
    > 即使是暂时的，以避免 UID 冲突。
+ 添加将在此项目上工作的作者（按目录或按文件）并为每个人分配唯一的 `AUID`
    > 随着时间的推移添加新作者是可能且容易的，但删除它们会更棘手。
+ 确保正确的作者处于活动状态（即你正在此设备上编辑此章节）
+ 关闭面板
+ 创建一个新场景，将其入口设置为项目的活动入口
+ 删除最初创建的旧场景

你可以继续了。

遵循上述步骤，将保证你永远不会在同一项目的不同文档中获得相同的 UID。

> **快速提示！**
> 一个好的预防措施是为你的[共享资源](#共享资源)保留章节 `0` 和/或作者 `0`。
> 继续阅读了解更多信息。

还要记住，你始终可以更改 `章节` ID 或任何贡献者的 `AUID`，
但更改这些值只会影响接下来要生成的 UID，而不会影响已经存在的 UID。
此功能允许许多有用的技巧，包括[共享资源](#共享资源)的技巧，
这就是为什么你最好先删除新项目的预设节点。

> 作者的额外 `info` 对 UID 生成没有影响，
> 那只是为了让你与世界分享信息，如果你想的话！

UID 冲突一开始可能看起来不是什么大问题。
当然，它可以通过一些运行时技巧和/或额外的簿记来解决；
但我们最好安全而不是抱歉，特别是在复杂的工作流程中，
充满了贡献复杂性和前方的技术并发症。

### 共享资源 {#共享资源}

Arrow 将每个项目文件视为完全隔离和独立的叙事。
换句话说，不支持工作空间状态共享、文档间链接等功能，也没有此类功能的计划。
好消息是我们需要的很大一部分已经在那里了。

由于无冲突的分布式 UID，你始终可以在运行时混合多个文档，
并通过使用自定义节点甚至 [Marker](../nodes/marker) 钩子来绕过限制
（例如在不同文档之间跳转）。
然而，仍有一些棘手的点需要处理。

一个问题是在运行时共享和同步全局变量（例如变量和角色标签）。

为了解决这个问题，你的运行时代码可以使用名称（而不是 UID）处理资源更新
（变量或角色标签）。
这可能是最简单的方法，技术复杂性最少。
在这种情况下，每次在运行时加载场景时，
所有尚未初始化的变量或角色
将在内存中创建，其值或标签等于场景中定义的初始状态。
如果它们已经初始化，它们的状态不会被重置。
这种方法真的很容易实现，并且可以从编辑器控制（不需要数据黑客）；
但共享资源名称中的简单拼写错误可能会在播放时造成混乱，
所以你需要在这方面格外小心。

另一种方法是让运行时正常使用 UID 处理资源更新。
我们只需要确保资源在另一个文件中使用时具有完全相同的 UID。
一种整洁干净的方法是有一个文件或部分（例如章节 `0` 和/或作者 `0`）作为 `base` 或根。
所有要共享的全局资源首先在此基础上创建并获得 UID。
然后我们可以使用 diff-merge 工具、手动编辑
或跨章节资源传输的*重用*模式（阅读下文）将这些资源块合并到其他文件中。
因为基础 UID 不会在更高级别的章节中创建，
我们预计不会有其他资源覆盖它们，并且可以使用它们的 UID 来处理它们。
这种方法几乎与名称无关，并允许共享和合并任何资源类型（包括宏），
但你需要使用本地资源名称处理暴露，并确保除非需要，否则不会重新初始化它们。

### 跨章节资源传输

高于 `2.0.0` 的 Arrow 编辑器版本还支持（实验性）资源合并器。
你可以使用 `Ctrl + Shift + C` 从网格中拾取选定的节点。
合并器所需的所有数据，包括所有引用的资源（变量、角色等），
也将被打包到一个 JSON 字符串中，该字符串将被推送到你的设备剪贴板。
你可以使用 `Ctrl + Shift + V` 将此块再次粘贴到任何其他章节的场景网格中。
你也可以使用相同的快捷键传输整个场景/宏、角色或变量，
同时在检查器面板的相应列表上聚焦。

粘贴时，根据底层情况，你可能有以下一种或多种
合并模式可用：

+ **重用**

    此方法保留导入到目标的所有资源的源 UID，*除非 UID 已被占用*。
    在后一种情况下，如果资源是变量或角色且内部类型相似，
    目标资源将被导入数据使用/引用，传输的源将被忽略。
    剩余资源（包括节点、场景和宏）从目标章节获得新 UID。
    
    > 此策略旨在在章节之间共享变量和角色（而不是使用合并工具）。
    > 它*不会更新*已共享的资源，并且仅在源和目标文档具有*不同章节 ID*时可用。

+ **重新创建**

    它更像是完全复制。在保留源的所有关系的同时，
    所有导入资源将从目标分配新 UID，即使其源 UID 未被占用。

默认情况下，如果导入数据的名称已被另一个资源使用，它们将被重命名（加后缀）。

在两种策略中，如果资源作为整体粘贴（到检查器列表中），
它们的托管场景（如果有）将被重新创建。然而，粘贴到网格上是不同的；
选定的节点将被移动到目标网格，
空场景（只有入口且未被引用的场景）将被丢弃。

[web-app]: https://mhgolkar.github.io/Arrow/
[Snowflake]: https://en.wikipedia.org/wiki/Snowflake_ID
