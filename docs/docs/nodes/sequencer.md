---
sidebar_position: 14
---

# 序列器节点 (Sequencer)

*Sequencer*（序列器）节点被设计为并行或排队运行多个出站槽（分支）。

**请极其谨慎处理！**  
Sequencer 的行为很大程度上取决于运行时代码，并且*可能不安全*。查看本文档的[使用](#使用)部分获取更多信息。

### 约定

+ 被跳过的 Sequencer 节点运行其最后连接的槽并短路。如果没有连接槽，则为 EOL。

+ Sequencer 是自动节点：它不等待用户交互。

+ 考虑到其自然目的，Sequencer 节点预期至少有两个出站槽。

+ Sequencer *请求*按顺序（从索引 `0` 开始）逐个播放其所有连接的槽。这些请求如何处理以及节点被播放的真实顺序取决于运行时代码。*按约定不保证顺序*。查看本文档的[使用](#使用)部分获取更多信息。

### 使用

虽然 Sequencer 节点请求按出站槽顺序播放其连接的分支，但它们实际上可能排队运行或并行运行（没有预期保证），取决于运行时实现。

它们也不关心正在播放的分支中的节点是自动的还是非自动的，它们只是触发/请求它们运行。

分支本身也可能有 Sequencer，最终以指数级意外的顺序运行。

这可能导致许多不同的意外行为，例如变量检查和更新顺序错误，在墙上显示多个等待用户操作的节点，以令人惊讶的方式打印内容等。

Sequencer 不对结果的合理性负责。责任全在您的肩上！

一个不安全的例子是序列化一个修改[变量](../getting-started/variables-logic)的分支和另一个更新或条件依赖于同一变量的分支。如果这些分支完全同步且排队运行，我们可以安全地假设第一个分支更新变量，然后第二个分支运行。但如果它们由运行时并行播放（例如通过多线程或某种没有保证消息顺序的通道），我们永远无法确定。

然而，使用 Sequencer 节点可以进行许多相对安全的操作。

一个例子是操作多个变量，即使是并行的，通过不相互依赖的操作。一个手动节点也可以跟在序列后面，以确保在我们等待用户操作的时间内所有操作都完成。

另一种可能性是设计运行时，使其实际上期望同时显示多个内容，并在需要时将它们排队。例如，运行时可以支持多个角色同时存在的场景。如果满足某个标准，每个角色都会说些什么。在这种情况下，按顺序请求的分支序列可能被并行处理，检查一些[变量](../getting-started/variables-logic)，如果[条件](./condition)正确，播放一些[对话](./dialog)，这些对话将被运行时添加到显示队列中，以适当的时机播放。

### 另请参阅

+ [导航和剧情管理](../getting-started/navigation-plot)
+ [随机器 (Randomizer)](./randomizer) 和 [集线器 (Hub)](./hub)
