---
sidebar_position: 3
---

# 项目数据结构

Arrow 章节文档结构在最顶层看起来像这样：

```js
{
    "title": "Untitled Adventure",
    "entry": 1, // 文档/章节主（活动）入口节点的资源 UID
    "meta": {
        // 原生（默认）分布式 UID 元数据：
        // > 对于分成多个 `.arrow` 文件的大型项目，
        // > 为每个文档（子项目）设置不同的章节 ID 可保证每个资源 UID 的全局唯一性。
        // > 这允许在同一运行时环境中运行不同章节而不会发生冲突。
        // > 最多可以存在 1024 个章节，表示为每个 UID 中的前 9 位。
        "chapter": 0, // (0 - 1024; 顺序是可选的。)
        // > Arrow 为每个作者使用增量种子追踪器，以保证多个用户同时处理同一文档时资源 UID 的唯一性。
        "authors": {
            // > 最多 64 个作者（表示为 UID 中的下 6 位）可以同时贡献。
            0: [Settings.ANONYMOUS_AUTHOR_INFO, 3] // [作者信息，以及下一个 UID 的增量种子]
        },
        // ...
        // 基于时间的分布式 UID 纪元：
        // > 作为默认（章节×作者×种子）分布式 UID 创建模型的替代方案，
        // > 您可以设置一个 epoch 属性，以获取受 Snowflake-ID 启发的 64 位基于时间的分布式 UID。
        // > 此属性应该是*项目*（而非文档）创建的 Unix 时间（UTC 微秒）。
        // > 不推荐使用此方法（时间×作者×序列 ID）。对于大多数项目，默认方法是更好的选择。
        // "epoch": null,
        // ...
        "last_save": null, // 最后保存时刻的 UTC 日期时间（ISO 8601）字符串
        "editor": Settings.ARROW_VERSION, // （用于版本兼容性检查）
        // ...
        // Arrow 具有 vcs 友好的项目结构（即唯一且从不重复使用的资源 ID、JSON 导出等），
        // 因此您可以轻松使用您喜欢的版本控制系统，如 Git。`offline` 和 `remote`
        // 属性主要保留用于将来可能的编辑器 vcs 集成，尽管目前没有官方计划。
        // 注意：不要删除这些元数据，因为它们可能已被用于其他目的或基础设施功能。
        "offline": true,
        "remote": {},
    },
    // ...
    // 全局增量 UID 追踪器（已弃用）：
    // > 如果存在，我们将此全局种子移动到章节 `0` 的作者 `0` 以保持向后兼容性。
    // "next_resource_seed": <int>,
    // ...
    // 最后是所有资源（如场景、节点、变量等）所在的位置：
    "resources": {
        // ...
    }
}
```

> JSON 导出共享相同的结构，但不包括开发者笔记等元数据。
> 其他格式如可播放的 `.html` 也带有嵌入的类似数据。
> 这些文件适合测试、审查或播放；但如果您需要重新导入数据进行编辑，
> 最好的选择是使用 JSON 格式的 `.arrow` 保存文件，它保留所有数据。

深入来看，每个 Arrow 项目的构建块都是 `resources`（资源）。

每个资源通过唯一标识符（UID）被 Arrow 识别。这些 UID 在设计上是分布式的，不会超过 64 位。

> 实际上，我们的 `Native` 算法默认配置为生成 53 位 UID 以适应双精度浮点数，
> 这使其适用于大整数（64 位）不可用的更受限语言。

UID 由 Arrow 设置，不应在保存的数据中手动编辑（除非您真的知道自己在做什么）。检查器中的（旧版）`[U]ID` 字段（您可以在其中编辑资源的标识）实际上编辑的是每个资源的 `name` 参数，它反映底层不可变的 UID（最初是 base-36 表示），并帮助更人性化地识别节点。

Arrow *不会*回收 UID，并且默认情况下*从不（重新）使用* UID 或名称用于不同的资源。

> 有关 UID 和名称参数的更多信息，请查看[项目组织](../getting-started/project-organization)页面。

有四种主要资源类型：
+ 场景和宏
+ 节点
+ 变量
+ 角色

所有资源按 UID 排序，在 `resources` 树中按各自类型分组。以下伪代码显示了它们的整体结构：

```js
{
    // ...,
    "resources": {
        "scenes" : { // （和宏）
            uid<i64>: { // <场景的资源 UID>
                "name": String<显示名称>,
                "entry": int<入口节点 UID>,
                "map": { // 节点如何以及按什么顺序在父场景中连接：
                    uid<int>: { // <场景中（子）节点的资源 UID>
                        "offset": [int<x>, int<y>], // 节点在网格上的位置
                        "skip": bool^可选,
                        "io": [ // 节点的*出站*连接列表，未排序
                            [ int<from_uid>, int<from_slot>, int<to_uid>, int<to_slot> ],
                            ...
                        ],
                    }, 
                    ...
                },
                "macro": bool^可选 // 将此场景标记为可重用资产，即宏。
            },
            ...
        },
        "nodes" : {
            uid<int>: {
                "type": String/Enum<节点类型>,
                "name": String<显示名称>,
                "data": {
                    // [取决于节点类型]
                },
                "notes": String^可选
            },
            ...
        },
        "characters": {
            uid<int>: {
                "name": String<显示名称>,
                "color": String<显示颜色>, // RGB[A]（十六进制，HTML 颜色）
                "tags": {
                    // 用户定义的自定义数据
                    String<键>: String<值>, ...
                }
            },
            ... 
        },
        "variables": {
            uid<int>: {
                "type": String/Enum<num|str|bool>,
                "name": String<显示名称>,
                "init": Variant<初始值>
            },
            ...
        }
    }
}
```

变量和节点资源有一个 `type` 属性，定义了我们期望的 `init`（初始值）或 `data` 的类型，以及应该如何处理这些数据。

为简洁起见，每个图形连接（网格上的两个节点）只需要一侧保留 `io` 数据，而且确实如此。按照惯例，它们是出站连接，提供更快的下一节点查找优势。

每个资源还可以有一个可选的 `use` 属性（数组），指示哪些其他（用户）资源依赖于此资源。另一个属性 `ref` 通过列出任何依赖资源的所有已使用（引用）资源来补充 `use`。

> `use` 和 `ref` 属性被视为元数据，主要用于在节点删除等操作期间保护连续性，
> 或便于使用其他资源定位节点。所有与播放相关的关系（例如 Jump 的目标节点）
> 应保留在节点的 `data` 属性中，因为其他元数据在运行时可能不可用。

每个有效文档都需要一个场景和一个 [Entry](../nodes/entry) 节点，以便控制台或运行时环境知道从哪里开始。

> 任何节点都可以设置为入口（通过手动编辑文档）；
> 但指定的类型提供多重安全检查，是编辑器支持的唯一方式。

章节文件是 *JSON 兼容的*，因此复杂数据类型在保存、加载、导入和导出时会被转换。例如，`Vector2(x,y)` 将存储为 `Array[x,y]`，整数键（或 UID）将保存为字符串。

宏是*可重用的 `scenes`*，其属性 `macro = true`，使它们在编辑器和运行时中的行为都不同。

> 请务必查看[项目组织](../getting-started/project-organization)以获取有关底层过程的更详细技术信息，
> 以及如何使用它们来控制不断增长的项目。
